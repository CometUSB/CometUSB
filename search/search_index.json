{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"CometUSB","text":""},{"location":"#python-package-for-linux-distributions-to-create-bootable-usb","title":"Python package for Linux distributions to create bootable USB.","text":""},{"location":"#description","title":"Description","text":"<p>This is a python package exclusively for linux distributions. It has list of linux distributions you can choose to create the bootable media. In the corresponding release section you will find the installation files of several linux distributions. </p>"},{"location":"#features","title":"Features","text":"<ul> <li>Create UEFI with GPT and Legacy BIOS with MBR bootable USBs.</li> <li>Dual-partition layout: In case of UEFI system two partitions first small FAT32 for boot then NTFS in rest of the space for other files are created.</li> <li>Single-partition layout: In case of legacy systems only one NTFS partition is created in the entire disk for both boot and installation files.</li> <li>Automatically install GRUB for UEFI or legacy systems.</li> <li>Only shows removable disk to format which prevents wiping your main HDD/SSD. This avoids significant data loss.</li> </ul>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#cometusb-core","title":"CometUSB Core","text":""},{"location":"api/#cometusb.cometusb.Operating_System","title":"<code>Operating_System</code>","text":"<p>This is the main object that contains all the information of the Operating System, target device and it's partition, bios-type etc. Once the create method is invoked it will start the process which includes wiping and formatting the target disk, downloading and extracting of files and applying bootloader.</p> Source code in <code>cometusb/cometusb.py</code> <pre><code>class Operating_System():\n    \"\"\"\n    This is the main object that contains all the information of the Operating System, target device and it's partition, bios-type etc.\n    Once the create method is invoked it will start the process which includes wiping and formatting the target disk, downloading and extracting of files and\n    applying bootloader.\n    \"\"\"\n    def __init__(self, name: str, bios_type: str):\n        self.name = name\n        self._path_url = f\"https://github.com/CometUSB/CometUSB/releases/download/{self.name}/\"\n        self.disk_size_reqd = self.name\n        self.bios_type = bios_type\n        self.partition_style = self.bios_type\n        self.target_disk = get_disk_details()\n        self.disk_partitions = format_disk(self.target_disk, self.bios_type, self.disk_size_reqd) # Dictionary of newly created partitions with labels\n        self.files = self.name\n        self._architecture= \"64 Bit\"\n\n\n    def __str__(self) -&gt; str:\n        return f\"\\nOS = {self.name.upper()}\\nArchitecture = {self._architecture}\\nTarget System BIOS Type = {self.bios_type}\\nTarget Device = {self.target_disk}\\nPartition Style = {self.partition_style.upper()}\\nFiles to be Downloaded = {[name for name in self.files.keys()]}\\n\"\n\n    @property\n    def name(self) -&gt; str:\n        return self._name\n\n    @name.setter\n    def name(self, name: str) -&gt; None:\n        \"\"\"\n        Sets name of the Operating System.\n\n        :param name: Name of the Operating System.\n        :type name: str\n        \"\"\"\n        OS: list = [\"linuxmint\"]\n        if name not in OS:\n            sys.exit(\"[!] Invalid or Unsupported Operating System.\\nEnter 'cometusb.py --OS-list' without quotes to see the supported list of Operating systems\")\n\n        self._name: str = name\n\n    @property\n    def partition_style(self) -&gt; str:\n        return self._partition_style\n\n    @partition_style.setter\n    def partition_style(self, bios_type: str) -&gt; None:\n        \"\"\"\n        Sets the partition style i.e, MBR or GPT.\n\n        :param bios_type: BIOS firmare type i.e, UEFI or Legacy.\n        :type bios_type: str\n        \"\"\"\n        if bios_type == \"uefi\":\n            self._partition_style: str = \"GPT\"\n\n        else:\n            self._partition_style: str = \"MBR\"\n\n\n    @property\n    def bios_type(self) -&gt; str:\n        return self._bios_type\n    @bios_type.setter\n    def bios_type(self, bios_type: str) -&gt; None:\n        \"\"\"\n        Sets the BIOS type.\n\n        :param bios_type: BIOS firmare type i.e, UEFI or Legacy.\n        :type bios_type: str\n        \"\"\"\n        if bios_type in [\"uefi\", \"legacy\"]:\n            self._bios_type: str = bios_type\n\n        else:\n            sys.exit(\"[!] Invalid BIOS type.\")\n\n    @property\n    def files(self) -&gt; dict:\n        return self._files\n\n    @files.setter\n    def files(self, name: str) -&gt; None:\n        \"\"\"\n        Selects files of given Operating System for Installation.\n\n        :param name: Name of the Operating System.\n        :type name: str\n        \"\"\"\n        if len(self.disk_partitions) == 2:\n            self._boot_partition, self._file_partition = self.disk_partitions.keys()\n        elif len(self.disk_partitions) == 1:\n            self._file_partition: str = [partition for partition in self.disk_partitions.keys()][0] # files_partition and boot_partition are the labels of boot partition and files partitions\n            self._boot_partition: str = self._file_partition\n\n        # Contains OS name and it's corresponding files and it's download path.\n        OS_FILES: dict = {\n        \"linuxmint\": {\n            \"boot.zip\": f\"/mnt/{self._boot_partition}/\",\n            \"directories.zip\":f\"/mnt/{self._file_partition}/\",\n            \"filesystem.squashfs.aa\": f\"/mnt/{self._file_partition}/\",\n            \"filesystem.squashfs.ab\": f\"/mnt/{self._file_partition}/\"\n        }\n        }\n\n        self._files: dict = OS_FILES[name]\n\n    @property\n    def disk_size_reqd(self):\n        return self._disk_size_reqd\n    @disk_size_reqd.setter\n    def disk_size_reqd(self, name):\n        \"\"\"\n        Calculates the size of disk required for process.\n\n        :param name: Name of the Operating System.\n        \"\"\"\n        OS_FILES = {\n            \"linuxmint\": [\n                \"boot.zip\",\n                \"directories.zip\",\n                \"filesystem.squashfs.aa\",\n                \"filesystem.squashfs.ab\"\n            ]\n        }\n\n        total_size: int = 0\n        for filename in OS_FILES[name]:\n            with requests.get(self._path_url + filename, stream = True) as response:\n                response.raise_for_status()\n                total_size += int(response.headers.get(\"content-length\", 0))\n\n        total_size = total_size / (1024 * 1024 * 1024) # Total files size.\n\n        USB_SIZES = [4, 8, 16, 32, 64]\n        for usb_size in USB_SIZES:\n            if usb_size / (total_size * 2) &gt; 1: # Divided by twice of the total_size because of merging of OS images will require space for merged file. Although splitted image files will be removed.\n                self._disk_size_reqd = usb_size\n                break\n\n    @property\n    def target_disk(self) -&gt; str:\n        return self._target_disk\n\n    @target_disk.setter\n    def target_disk(self, target_disk: str) -&gt; None:\n        \"\"\"\n        Sets the target disk.\n\n        :param target_disk: Name of the target disk.\n        :type target_disk: str\n        \"\"\"\n        self._target_disk: str = target_disk\n\n    @property\n    def disk_partitions(self) -&gt; dict:\n        return self._disk_partitions\n\n    @disk_partitions.setter\n    def disk_partitions(self, partitions: dict) -&gt; None:\n        \"\"\"\n        Sets partitions with of the target disk.\n\n        :param partitions: Dictionary of all the newly created partition of target disk with corresponding labels.\n        :type partitions: dict\n        \"\"\"\n        self._disk_partitions: dict = partitions\n\n    def bootloader(self) -&gt; None:\n        \"\"\"\n        Applies bootloader to the partition of the target disk containing boot files.\n        \"\"\"\n        print(f\"Applying bootloader on {self.target_disk} for {self.bios_type} systems...\")\n        if self.bios_type == \"uefi\":\n            subprocess.run([\"sudo\", \"grub-install\" ,\"--target=x86_64-efi\", f\"--efi-directory=/mnt/{self._boot_partition}\", f\"--boot-directory=/mnt/{self._boot_partition}/boot\", \"--removable\"])\n\n        else: \n            subprocess.run([\"sudo\", \"grub-install\" ,\"--target=i386-pc\", f\"--boot-directory=/mnt/{self._boot_partition}/boot\", f\"{self.target_disk}\"])\n\n    def create(self) -&gt; None:\n        \"\"\"\n        This method calls all the required functions in sequence to perform the necessary operations to make the bootable media.\n        \"\"\"\n        # Mounting newly created partitions.\n        mount_usb(self.disk_partitions)\n\n        # Disk configuration info. \n        print(f\"\\n[*] Disk {self.target_disk} configuration.\")\n        subprocess.run([\"lsblk\", self.target_disk, \"-o\", \"NAME,SIZE,FSTYPE,FSVER,LABEL,MOUNTPOINTS\"])\n\n        for filename, download_dir in self.files.items():\n            print() #To create gap between progress bars.\n            print(f\"Downloading {filename} into {download_dir}\")\n            downloader(self._path_url + filename, download_dir)\n            print() #To create gap between progress bars.\n            if filename.endswith(\".zip\"):\n                # Extracting to create the directory tree structure\n                extractor(download_dir + filename, download_dir)\n                print() #To create gap between progress bars.\n                os.remove(download_dir + filename) # Removing the zip file after extracting to free space in the USB.\n            if filename.endswith(\".aa\"):\n                image_name, download_dir = filename.rstrip(\".aa\"), download_dir\n        print(f\"[*] Making OS Image {image_name} ready for installation.\\n[*] This may take a while depending upon your removable disk {self.target_disk}.\")\n        subprocess.run(f\"sudo cat {download_dir}{image_name}.* &gt; {download_dir}casper/{image_name}\", shell=True, stdout=subprocess.DEVNULL)\n\n        print(\"[*] Cleaning unnecessary file...\")\n        for splitted_image_file in glob.glob(f\"{download_dir}{image_name}.*\"):\n            os.remove(splitted_image_file)\n\n        # Applying bootloader\n        self.bootloader()\n\n        print(\"Media created succesfully\\nNOTE: Linux disk sometimes is not detected in BIOS, try disabling secure boot of your BIOS if facing any issues while booting.\")\n</code></pre>"},{"location":"api/#cometusb.cometusb.Operating_System.bootloader","title":"<code>bootloader()</code>","text":"<p>Applies bootloader to the partition of the target disk containing boot files.</p> Source code in <code>cometusb/cometusb.py</code> <pre><code>def bootloader(self) -&gt; None:\n    \"\"\"\n    Applies bootloader to the partition of the target disk containing boot files.\n    \"\"\"\n    print(f\"Applying bootloader on {self.target_disk} for {self.bios_type} systems...\")\n    if self.bios_type == \"uefi\":\n        subprocess.run([\"sudo\", \"grub-install\" ,\"--target=x86_64-efi\", f\"--efi-directory=/mnt/{self._boot_partition}\", f\"--boot-directory=/mnt/{self._boot_partition}/boot\", \"--removable\"])\n\n    else: \n        subprocess.run([\"sudo\", \"grub-install\" ,\"--target=i386-pc\", f\"--boot-directory=/mnt/{self._boot_partition}/boot\", f\"{self.target_disk}\"])\n</code></pre>"},{"location":"api/#cometusb.cometusb.Operating_System.create","title":"<code>create()</code>","text":"<p>This method calls all the required functions in sequence to perform the necessary operations to make the bootable media.</p> Source code in <code>cometusb/cometusb.py</code> <pre><code>def create(self) -&gt; None:\n    \"\"\"\n    This method calls all the required functions in sequence to perform the necessary operations to make the bootable media.\n    \"\"\"\n    # Mounting newly created partitions.\n    mount_usb(self.disk_partitions)\n\n    # Disk configuration info. \n    print(f\"\\n[*] Disk {self.target_disk} configuration.\")\n    subprocess.run([\"lsblk\", self.target_disk, \"-o\", \"NAME,SIZE,FSTYPE,FSVER,LABEL,MOUNTPOINTS\"])\n\n    for filename, download_dir in self.files.items():\n        print() #To create gap between progress bars.\n        print(f\"Downloading {filename} into {download_dir}\")\n        downloader(self._path_url + filename, download_dir)\n        print() #To create gap between progress bars.\n        if filename.endswith(\".zip\"):\n            # Extracting to create the directory tree structure\n            extractor(download_dir + filename, download_dir)\n            print() #To create gap between progress bars.\n            os.remove(download_dir + filename) # Removing the zip file after extracting to free space in the USB.\n        if filename.endswith(\".aa\"):\n            image_name, download_dir = filename.rstrip(\".aa\"), download_dir\n    print(f\"[*] Making OS Image {image_name} ready for installation.\\n[*] This may take a while depending upon your removable disk {self.target_disk}.\")\n    subprocess.run(f\"sudo cat {download_dir}{image_name}.* &gt; {download_dir}casper/{image_name}\", shell=True, stdout=subprocess.DEVNULL)\n\n    print(\"[*] Cleaning unnecessary file...\")\n    for splitted_image_file in glob.glob(f\"{download_dir}{image_name}.*\"):\n        os.remove(splitted_image_file)\n\n    # Applying bootloader\n    self.bootloader()\n\n    print(\"Media created succesfully\\nNOTE: Linux disk sometimes is not detected in BIOS, try disabling secure boot of your BIOS if facing any issues while booting.\")\n</code></pre>"},{"location":"api/#cometusb.cometusb.main","title":"<code>main()</code>","text":"Source code in <code>cometusb/cometusb.py</code> <pre><code>def main() -&gt; None:\n    parser = argparse.ArgumentParser(\n                    prog= \"CometUSB.\",\n                    description=\"Create linux bootable USB.\"\n                    )\n    parser.add_argument(\"-l\", \"--list-os\", action=\"store_true\", help=\"Shows list of the available Operating Systems.\")\n    parser.add_argument(\"-o\", \"--operating-system\", help=\"Name of the Operating System.\")\n    parser.add_argument(\"-b\",\"--bios-type\", help=\"BIOS type (e.g., UEFI or Legacy), check what your TARGET SYSTEM supports.\")\n    args = parser.parse_args()\n\n    # List of available Opereating System\n    OS = [\"linuxmint\"]\n\n    # Shows list of available Operating Systems.\n    if args.list_os:\n        for number in range(len(OS)):\n            print(number + 1, OS[number], sep=\". \")\n        sys.exit() # Exits after showing the OS list\n    operating_system = Operating_System(args.operating_system.lower(), args.bios_type.lower())\n    print(operating_system)\n    operating_system.create()\n</code></pre>"},{"location":"api/#cometusb.cometusb.get_disk_details","title":"<code>get_disk_details()</code>","text":"<p>Executes the 'lsblk' command to retrieve detailed information for physical block disks using JSON output for robust, programmatic parsing.</p> <p>:return: A string of target device. :rtype: str</p> Source code in <code>cometusb/cometusb.py</code> <pre><code>def get_disk_details() -&gt; str:\n    \"\"\"\n    Executes the 'lsblk' command to retrieve detailed information for physical\n    block disks using JSON output for robust, programmatic parsing.\n\n    :return: A string of target device.\n    :rtype: str\n    \"\"\"\n\n    LSBLK_CMD = ['lsblk', '-d','-J', '-o', 'NAME,SIZE,VENDOR,MODEL,RM']\n\n\n    # Execute the command, capture output, and ensure success\n    result = subprocess.run(\n        LSBLK_CMD, \n        capture_output=True, \n        text=True,\n        check=True\n    )\n\n    # Parse the JSON output into a Python dictionary\n    data = json.loads(result.stdout)\n\n    # Extract and filter the block disks\n\n\n    disks = [\n                [\n                    disk.get('name', 'N/A'), \n                    disk.get('size', 'N/A'),\n                    disk.get('vendor', 'N/A'),\n                    disk.get('model', 'N/A')\n                ]\n                for disk in data.get('blockdevices', []) if disk.get('rm', 'N/A') == True\n            ]\n\n    if not disks:\n        sys.exit(\"No USB/removable media found.\")\n    headers = [header.capitalize() for header in data.get(\"blockdevices\")[0].keys()]\n    headers[2] = \"Interface\" # Renaming Vendor column to Interface\n    print(tabulate(disks, headers=headers, tablefmt=\"grid\"))\n\n\n    return f\"/dev/{input(\"Enter disk: \")}\"\n</code></pre>"},{"location":"api/#cometusb.cometusb.format_disk","title":"<code>format_disk(disk, bios_type, size)</code>","text":"<p>Formats the target disk, converts it into GPT or MBR then create partitions and filesystems compatible for the given BIOS Type i.e, UEFI or Legacy. </p> <p>:param disk: Name of target disk.  :type disk: str :param bios_type: BIOS firmware type. :type bios_type: str :param size: Size of the target disk required. :return: Dictionary of all the partition of target disk with corresponding labels. :rtype: str</p> Source code in <code>cometusb/cometusb.py</code> <pre><code>def format_disk(disk: str, bios_type: str, size: int) -&gt; str:\n    \"\"\"\n    Formats the target disk, converts it into GPT or MBR then create partitions and filesystems compatible for the given BIOS Type i.e, UEFI or Legacy. \n\n    :param disk: Name of target disk. \n    :type disk: str\n    :param bios_type: BIOS firmware type.\n    :type bios_type: str\n    :param size: Size of the target disk required.\n    :return: Dictionary of all the partition of target disk with corresponding labels.\n    :rtype: str\n    \"\"\"\n     # Confirming to Format the USB\n    print(f\"\\n[!] MINIMUM {size} GB Disk is required.\\n[*] This will ERASE all data on {disk}\") \n    if input(\"Type 'yes' to continue: \").strip().lower() != \"yes\":\n        sys.exit(\"Aborted by user.\")\n\n    partitions = glob.glob(disk + \"?\")\n    unmount_usb(partitions)\n    try:\n\n        # Wipe partition table\n        print(f\"\\n[*] Wiping disk {disk}\")\n        subprocess.run([\"sudo\", \"wipefs\", \"-a\", disk], check=True)\n\n        print(f\"\\n[*] Creating partitions for {bios_type} systems...\")\n        if bios_type == \"uefi\":\n            # Create new partition table and partition\n            subprocess.run([\"sudo\", \"parted\", \"-s\", disk, \"mklabel\", \"gpt\"], check=True)\n            subprocess.run([\"sudo\", \"parted\", \"-s\", disk, \"mkpart\", \"primary\", \"1MiB\", \"501MiB\"], check=True)\n            partition = glob.glob(disk + \"?\")\n            boot_partition = partition[0]\n            subprocess.run([\"sudo\", \"parted\", \"-s\", disk, \"mkpart\", \"primary\", \"501MiB\", \"100%\"], check=True)\n            partition = glob.glob(disk + \"?\")\n            partition.remove(boot_partition)\n            files_partition = partition[0]\n\n            # Refreshing the partitions\n            subprocess.run([\"sudo\", \"partprobe\", disk], check=True)\n            subprocess.run([\"sudo\", \"udevadm\", \"settle\"], check=True)\n\n            # Creating the filesystems\n            print(f\"\\n[*] Creating filesystems ...\")\n            subprocess.run([\"sudo\", \"mkfs.fat\", \"-F\", \"32\", \"-n\", \"COMET_BOOT\", boot_partition], check=True)\n            subprocess.run([\"sudo\", \"parted\", \"-s\", disk, \"set\", \"1\", \"esp\", \"on\"], check=True)    \n            subprocess.run([\"sudo\", \"mkfs.ntfs\", \"-f\", files_partition, \"-L\", \"COMET_FILES\"], check=True)\n\n        elif bios_type == \"legacy\":\n            # Create new partition table and partition\n            subprocess.run([\"sudo\", \"parted\", \"-s\", disk, \"mklabel\", \"msdos\"], check=True)\n            subprocess.run([\"sudo\", \"parted\", \"-s\", disk, \"mkpart\", \"primary\", \"0%\", \"100%\"], check=True)\n            partition = glob.glob(disk + \"?\")\n\n            files_partition = partition[0] # Only one partition is here same for installation and boot files.\n\n            # Refreshing the partitions\n            subprocess.run([\"sudo\", \"partprobe\", disk], check=True)\n            subprocess.run([\"sudo\", \"udevadm\", \"settle\"], check=True)\n\n            # Creating the filesystems\n            print(f\"\\n[*] Creating filesystems ...\")\n\n            subprocess.run([\"sudo\", \"mkfs.ntfs\", \"-f\", files_partition, \"-L\", \"COMET\"], check=True)\n            subprocess.run([\"sudo\", \"parted\", \"-s\", disk, \"set\", \"1\", \"boot\", \"on\"], check=True) \n\n        print(f\"[*] USB {disk} formatted successfully!\\n\")\n\n    except subprocess.CalledProcessError:\n        sys.exit(\"[*] Something went wrong, please retry.\")\n\n    if len(glob.glob(disk + \"?\")) == 2:\n        return {\"COMET_BOOT\": boot_partition, \"COMET_FILES\": files_partition}\n    else:\n        return {\"COMET\": files_partition}\n</code></pre>"},{"location":"api/#cometusb.cometusb.unmount_usb","title":"<code>unmount_usb(partitions)</code>","text":"<p>Unmounts all the existing partitions of the target disk to intitate the formatting process by format_disk function.</p> <p>:param partitions: List of all the partitions in the target disk. :type partitions: list</p> Source code in <code>cometusb/cometusb.py</code> <pre><code>def unmount_usb(partitions: list) -&gt; None:\n    \"\"\"\n    Unmounts all the existing partitions of the target disk to intitate the formatting process by format_disk function.\n\n    :param partitions: List of all the partitions in the target disk.\n    :type partitions: list\n    \"\"\"\n\n    for part in partitions:\n        print(f\"Unmounting: {part}\")\n        subprocess.run([\"sudo\", \"umount\", \"-f\", part])\n</code></pre>"},{"location":"api/#cometusb.cometusb.mount_usb","title":"<code>mount_usb(partitions)</code>","text":"<p>Mounts all the newly created partitions of the target disk by format_disk function.</p> <p>:param partitions: Dictionary of all the newly created partition of target disk with corresponding labels. :type partitions: dict</p> Source code in <code>cometusb/cometusb.py</code> <pre><code>def mount_usb(partitions: dict) -&gt; None:\n    \"\"\"\n    Mounts all the newly created partitions of the target disk by format_disk function.\n\n    :param partitions: Dictionary of all the newly created partition of target disk with corresponding labels.\n    :type partitions: dict\n    \"\"\"\n    for part_label in partitions.keys():\n        print(f\"Mounting: {partitions[part_label]} on /mnt/{part_label}\")\n        subprocess.run([\"sudo\", \"mkdir\", \"-p\", f\"/mnt/{part_label}\"])\n        result = subprocess.run([\"sudo\", \"mount\", partitions[part_label], f\"/mnt/{part_label}\"])\n        if result.returncode &gt; 8:\n            sys.exit(f\"\\n[*] Failed to mount {partitions[part_label]} on /mnt/{part_label}.\\n[*] Please retry...\")\n</code></pre>"},{"location":"api/#cometusb.cometusb.downloader","title":"<code>downloader(url, download_dir)</code>","text":"<p>Downloads all the files from github release page of the corresponding operating system of the CometUSB organization.</p> <p>:param url: Download URL of individual files. :type url: str :param download_dir: Download location of the given files. :type download_dir: str</p> Source code in <code>cometusb/cometusb.py</code> <pre><code>def downloader(url: str, download_dir: str) -&gt; None:\n    \"\"\"\n    Downloads all the files from github release page of the corresponding operating system of the CometUSB organization.\n\n    :param url: Download URL of individual files.\n    :type url: str\n    :param download_dir: Download location of the given files.\n    :type download_dir: str\n    \"\"\"\n    with requests.get(url, stream = True) as response:\n        response.raise_for_status()\n        total_size: int = int(response.headers.get(\"content-length\", 0))\n        chunk_size: int = 1024 * 200 # 200KB chunk for smoother progress update.\n        with open(f\"{download_dir}{os.path.basename(url)}\", \"wb\") as file, tqdm(\n            total = total_size,\n            unit = \"B\",\n            unit_scale = True,\n            unit_divisor = 1024,\n            desc = f\"{os.path.basename(url)}\"\n        ) as progress:\n            for chunk in response.iter_content(chunk_size = chunk_size):\n                download = file.write(chunk)\n                progress.update(download)\n</code></pre>"},{"location":"api/#cometusb.cometusb.extractor","title":"<code>extractor(archive_path, extract_dir)</code>","text":"<p>Extracts the compressed archive to given location.</p> <p>:param archive_path: Complete path of the compressed archives. :type archive_path: str :param extract_dir: Extract folder for the corresponding archive. :type extract_dir: str</p> Source code in <code>cometusb/cometusb.py</code> <pre><code>def extractor(archive_path: str, extract_dir: str) -&gt; None:\n    \"\"\"\n    Extracts the compressed archive to given location.\n\n    :param archive_path: Complete path of the compressed archives.\n    :type archive_path: str\n    :param extract_dir: Extract folder for the corresponding archive.\n    :type extract_dir: str\n    \"\"\"\n    with zf.ZipFile(archive_path, \"r\") as archive, tqdm(\n        total = sum(file_info.file_size for file_info in archive.infolist()),\n        unit = \"B\",\n        unit_scale = True,\n        unit_divisor = 1024,\n        desc = f\"Extracting {os.path.basename(archive_path)}\"\n    ) as progress:\n\n        for file_info in archive.infolist():\n\n            archive.extract(file_info, path = extract_dir)\n            progress.update(file_info.file_size)\n</code></pre>"},{"location":"cli/","title":"CLI Reference","text":""},{"location":"cli/#required-arguments","title":"Required Arguments","text":"Option Long Option Description Example <code>-o</code> <code>--operating-system</code> Name of the Operating System to download and install. <code>-o linuxmint</code> <code>-b</code> <code>--bios-type</code> BIOS type (boot mode) for the target system. Specifies the partitioning scheme (GPT/MBR) and GRUB installation method. <code>-b uefi</code>"},{"location":"cli/#optional-arguments","title":"Optional Arguments","text":"Option Long Option Description <code>-l</code> <code>--list-os</code> Shows a list of the currently available and supported Operating Systems. <code>-h</code> <code>--help</code> Show the help message and exit."},{"location":"installation/","title":"Installation","text":"<p>CometUSB is a Python package available on PyPI. It requires Python 3.8 or higher.</p>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<p>Before installation, ensure you have:</p> <ul> <li>Linux Distribution: CometUSB is exclusively for Linux.</li> <li>Python 3.8+: Installed on your system.</li> <li>Administrative Rights (<code>sudo</code>): The tool requires <code>sudo</code> privileges to manage disks and partitions.</li> </ul>"},{"location":"installation/#install-via-pip","title":"Install via pip","text":"<p>The most straightforward way to install CometUSB is using <code>pip</code>:</p> <p><pre><code>pip install cometusb\nor\n# Using python -m pip (recommended for virtual environments)\npython -m pip install cometusb\nor\npython3 -m pip install cometusb\n</code></pre> If none of the above commands work, find out how to install python package in your system.</p>"},{"location":"internals/","title":"Internals: Working of CometUSB.","text":"<p>This document details the architecture, execution flow, and core logic behind the <code>cometusb</code> utility. It is intended for developers, contributors, and advanced users seeking a deep understanding of the project.</p>"},{"location":"internals/#1-core-workflow-pipeline","title":"1. Core Workflow Pipeline","text":"<p>The entire process of creating the bootable drive is controlled by the <code>Operating_System</code> class and its public method, <code>create()</code>. The operation follows a strict, sequential 5-stage pipeline to ensure drive is properly bootable.</p> Step Function Executed Purpose and Technical Details 1. Preparation <code>unmount_usb</code> Ensures Disk Access: Uses <code>subprocess</code> to execute <code>umount</code> on all detected partitions of the target device (<code>/dev/device_name?</code>). This is critical to prevent \"Device or resource busy\" errors during the subsequent disk wipe. 2. Formatting <code>format_disk</code> Partitioning and Filesystems: Executes <code>sudo wipefs -a</code> to destroy the old partition table, then uses <code>parted</code> to create the new GPT or MBR table. Finally, <code>mkfs.fat</code> and <code>mkfs.ntfs</code> format the new partitions. 3. Downloading <code>downloader</code> Reliable Fetching: Uses the <code>requests</code> library with <code>tqdm</code> to download all required files (split images, archives, checksums) from the GitHub Releases server, providing a visual progress bar. 4. Extraction <code>extractor</code> File Placement: Extracts compressed archives (e.g., <code>boot.zip</code>) to the newly mounted partitions. Uses <code>tqdm</code> for extraction progress tracking. 5. Bootloader <code>bootloader</code> Making it Bootable: Installs the GRUB bootloader. The installation target is conditionally set to <code>x86_64-efi</code> for UEFI/GPT systems or <code>i386-pc</code> for Legacy/MBR systems."},{"location":"internals/#2-low-level-partitioning-logic","title":"2. Low-Level Partitioning Logic","text":"<p>The tool's fundamental disk management is based on the user's choice of BIOS type, dictating the underlying partition table and filesystem layout.</p> BIOS Type Disk Standard Partition Scheme Partitions Label / Size / Filesystem Rationale UEFI GPT (GUID Partition Table) Dual-Partition 1. COMET_BOOT: 500 MiB, FAT32 (ESP).  2. COMET_FILES: Remaining space, NTFS. Required for UEFI: FAT32 ESP is mandatory for EFI firmware. NTFS is used for the data partition to overcome single-file size restriction. Legacy MBR (Master Boot Record) Single-Partition 1. COMET: Entire disk, NTFS. Simplicity: A single NTFS partition is sufficient for Legacy booting and simplifies file management for the user."},{"location":"internals/#3-file-handling","title":"3. File Handling","text":"<p>The reliability of CometUSB heavily depends on its robust file handling.</p>"},{"location":"internals/#splitting-os-image","title":"Splitting OS image.","text":"<p>The large OS image like <code>filesystem.squashfs</code> file is downloaded in split parts (<code>filesystem.squashfs.aa</code>, <code>filesystem.squashfs.ab</code>, etc.). These parts are reconstructed using the Linux <code>cat</code> utility. The splitting is done to comply with the GitHub file size restriction for release pages i.e, Cannot store a file of size more than 2 GB.</p>"},{"location":"internals/#compressing-of-contents","title":"Compressing of Contents.","text":"<p>There are plently(2000+) of smaller files essential for installation. So for reliable downloading, these files are archived into .zip and uploaded.</p>"},{"location":"internals/#sequence-of-downloading-and-extraction","title":"Sequence of Downloading and Extraction.","text":"<ul> <li>First Boot.zip which contains boot files required to boot is downloaded and extracted in the boot partition. Boot.zip is removed after extraction.</li> <li>Then directories.zip which contains all the smaller files is downloaded and extracted it also make the directories structure. directories.zip is also removed after the extraction.</li> <li>Spilitted OS images is then downloaded and merged via cat utility of linux and moved to the original required folder. This folder will be present beforehand after the extraction of directories.zip in earlier step above.</li> <li>All of these file read and write are done in the removable media itself, avoiding any overloading to the storage of the host system.</li> </ul>"},{"location":"internals/#4-source-code-mapping","title":"4. Source Code Mapping","text":"Component Responsibility Area Key Source Element Application Flow Program entry point, argument parsing, OS object instantiation. <code>cometusb.py</code> (<code>main</code> function). State Management Encapsulates all job data (OS, disk, partitions, files). <code>cometusb.py</code> (<code>Operating_System</code> class). Disk Utilities Listing, Partitioning, formatting, unmounting, and mounting disk devices. <code>cometusb.py</code> (<code>get_disk_details</code>, <code>format_disk</code>, <code>unmount_usb</code>, <code>mount_usb</code> functions). File Transfer Handling HTTP streams, progress tracking, and file extraction. <code>cometusb.py</code> (<code>downloader</code>, <code>extractor</code> functions). Bootloader Applying grub-install on the disk as per given BIOS Type (UEFI/Legacy). <code>bootloader</code> method in the Operating_System class applies the bootloader after checking the BIOS Type."},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>Here are solutions for common issues encountered when using CometUSB:</p>"},{"location":"troubleshooting/#1-permission-denied","title":"1. Permission Denied","text":"<p>Error: <code>PermissionError: [Errno 13] Permission denied</code> or general failures when accessing <code>/dev/sdX</code>.</p> <p>Solution: CometUSB must manage disk devices, which requires root access. Always run the tool using <code>sudo</code>.</p> <p>e.g, <code>sudo cometusb -o linuxmint -b uefi</code></p>"},{"location":"troubleshooting/#2-active-internet-connection","title":"2. Active Internet Connection","text":"<p>This tool downloads the installation files from the github release. Make sure you have a working and stable connection.</p>"},{"location":"troubleshooting/#3-storage-required","title":"3. Storage Required","text":"<p>This tools downloads the files in the removable disk and do all the operations like extracting, merging the OS image files in the disk itself, so that it does not rely on the host system to store the files. Therefore, before wiping the disk out it a confirmation option will be prompted, there you can see the size of the disk required, make sure you have atleast that much size of disk.</p>"},{"location":"troubleshooting/#4-firmware-detection","title":"4. Firmware Detection","text":"<p>Sometime Linux bootable USB is not detected by your BIOS, try switching off the secure boot option in your BIOS.</p>"},{"location":"usage/","title":"Usage Guide","text":"<p>CometUSB is run directly from the command line, requiring administrative privileges (<code>sudo</code>) because it must access and format your physical disk devices.</p>"},{"location":"usage/#basic-command-structure","title":"Basic Command Structure","text":"<p>You must always specify the Operating System name (<code>-o</code>) and the target system's BIOS type (<code>-b</code>).</p> <p><code>sudo cometusb -o &lt;OS_NAME&gt; -b &lt;BIOS_TYPE&gt;</code></p> <p>or</p> <p><code>sudo cometusb --operating-system &lt;OS_Name&gt; --bios-type &lt;BIOS_TYPE&gt;</code></p> <p>e.g, <code>sudo cometusb -o linuxmint -b uefi</code></p> <p>Type <code>cometusb -h</code> or <code>cometusb --help</code> to see the usage</p> <p>Type <code>cometusb --list-os</code> or <code>cometusb -l</code> to see the list of available Operating System</p>"}]}